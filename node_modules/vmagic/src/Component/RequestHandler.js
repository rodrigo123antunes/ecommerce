/*eslint max-statements: ["error", 100],  max-lines: ["error", 500]*/
'use strict';

var url = require('url');
var FactoryController = require('../Controller/FactoryController.js');
var Logger = require('../Component/Logger.js');
var packageJSON = require('../../package.json');
var multiparty = require('multiparty');

class RequestHandler {

    constructor(application) {
        this.application = application;
        this.factoryController = new FactoryController(this.application);
        this.instance = this.factoryController;
        this.logger = new Logger();
    }

    /**
     * [getPayload description]
     * @param  {[type]}   request  [description]
     * @param  {Function} callback [description]
     * @return {[type]}            [description]
     */
    getPayload(request, callback) {
        const that = this;
        this.payload = {};
        if (request.headers['content-type'].indexOf("multipart/form-data") > -1) {
            const form = new multiparty.Form();
            if (Reflect.has(this.factoryController.core, "uploadDir")) {
                form.autoFiles = true;
                form.uploadDir = this.factoryController.core.uploadDir;
            }
            form.parse(request, function(err, fields, files) {
                if (err) {
                    that.logger.error(`[Magic] ${JSON.stringify(err, null, 4)}`);
                    request.connection.destroy();

                    return;
                }

                const data = {};
                for (var key in fields) {
                    if (Reflect.has(fields, key)) {
                        data[key] = fields[key][0];
                    }
                }

                that.payload = {
                    "data" : data,
                    "files" : files
                };
                that.logger.info(`[Magic] Payload ${JSON.stringify(that.payload, null, 4)}`);
                callback(that.payload);
            });
        } else {
            let body = '';
            request.on('data', data => {
                body += data;

                //Too much POST data, kill the connection!
                if (body.length > 1e6) {
                    request.connection.destroy();
                }
            });
            request.on('end', () => {
                if (body !== '') {
                    this.payload = JSON.parse(body);
                }
                this.logger.info(`[Magic] Payload ${JSON.stringify(this.payload, null, 4)}`);
                callback(this.payload);
            });
        }
    }

    /**
     * [getQuery description]
     * @param  {[type]}   request  [description]
     * @param  {Function} callback [description]
     * @return {[type]}            [description]
     */
    getQuery(request, callback) {
        var query = url.parse(request.url, true).query;
        this.logger.info(`[Magic] QueryString ${JSON.stringify(query, null, 4)}`);
        callback(query);
    }

    /**
     * [getParamsURL description]
     * @param  {[type]} request [description]
     * @return {[type]}         [description]
     */
    getParamsURL(request) {
        var index = null;
        var params = null;
        var ctrlName = null;
        var action = null;
        var id = null;
        var controller = null;

        /*----------  If exists queryString on url  ----------*/
        index = request.url.indexOf('?');
        if (index > -1) {
            params = request.url.substring(0, index).split('/');
        } else {
            params = request.url.split('/');
        }

        /*----------  If controller is different of empty  ----------*/
        ctrlName = params[1];
        if (ctrlName === '') {
            throw new Error(`Resource not found.`);
        }

        if (isNaN(params[2])) {
            action = params[2];
            id = params[3];
        } else {
            id = params[2];
        }

        try {
            controller = this.instance.controller(ctrlName);
        } catch (ex) {
            if (ex.message.indexOf('Cannot find module') != -1) {
                if (ex.message.indexOf('src/Controller') != -1) {
                    throw new Error(`${ctrlName}Controller not found.`);
                }

                throw new Error(ex.message);
            }
        }

        return {'controller' : controller, 'action' : action, 'id' : id};
    }

    /**
     * [terminate description]
     * @param  {[type]} request  [description]
     * @param  {[type]} response [description]
     * @param  {[type]} data     [description]
     * @return {[type]}          [description]
     */
    terminate(request, response, data) {
        this.request = request;
        this.response = response;
        this.data = data;

        if (data.statusCode) {
            this.response.writeHead(data.statusCode, {'Content-Type': 'application/json'});
        } else {
            this.response.writeHead(200, {'Content-Type': 'application/json'});
        }

        this.response.end(JSON.stringify(this.data));
        this.request.connection.destroy();
    }

    /**
     * This is called before each http request.
     * @param {Object} controller resource
     * @param {function} callback response
     * @returns {Void} It's doens't return.
     */
    beforeFilter(controller, callback) {
        this.controller = controller;
        this.callback = callback;
        if (typeof this.controller.beforeFilter !== "undefined") {
            this.controller.beforeFilter(callback);

            return;
        }

        this.callback();
    }

    /**
     * This method invoke an action method from a controller.
     * @param  {Object} params  [description]
     * @param  {Object} request  [description]
     * @param  {Object} response [description]
     * @param  {function} callback [description]
     * @return {Void} [description]
     */
    callAction(params, request, response, callback) {
        if (!params.controller[params.action]) {
            this.logger.error(`Action /${params.action} not found.`);
            this.terminate(request, response, {'Error' : `Action /${params.action} not found.`, 'statusCode' : 404});

            return;
        }

        params.controller[params.action](callback);
    }

    /**
     * This function is called whenever http request is received.
     * @param {Object} request .
     * @param {Object} response .
     * @return {VoidFunction} .
     */
    process(request, response) {
        //Website you wish to allow to connect.
        response.setHeader('Access-Control-Allow-Origin', '*');
        //Request method you wish to allow.
        response.setHeader('Access-Control-Request-Method', '*');
        //Request methods you wish to allow
        response.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS, PATCH');
        //Request headers you wish to allow
        response.setHeader('Access-Control-Allow-Headers', 'X-Requested-With, Content-Type, Authorization');
        //Set to true if you need the website to include cookies in the requests sent to the API (e.g. in case you use sessions)
        response.setHeader('Access-Control-Allow-Credentials', true);

        this.headersInfo = request.headers;
        this.headersInfo.url = request.url;
        this.headersInfo.method = request.method;
        this.headersInfo.statusCode = request.statusCode;
        this.logger.info(`[Magic] Request Data ${JSON.stringify(this.headersInfo, null, "\t")}`);

        let params = null;

        try {
            params = this.getParamsURL(request);
            if (!params.controller) {
                throw new Error("The vMagic cannot process request. Make sure there are no errors in your API files.");
            }
            params.controller.headersInfo = this.headersInfo;
        } catch (ex) {
            //It returns the framework version when not exists action.
            if (ex.message === 'Resource not found.') {
                this.logger.warn(`[Magic] Version ${packageJSON.version}`);
                this.terminate(request, response, {"name" : "vMagic Framework", "version" : packageJSON.version});

                return;
            }

            this.logger.error(`[Magic] ${ex.message}`);
            this.terminate(request, response, {'Error' : ex.message, 'statusCode' : 500});

            return;
        }

        //Get param id.
        if (typeof params.id !== "undefined") {
            params.controller.id = params.id;
        }

        /**
         * It's returns a JSON to client.
         * @param  {[type]}   data [description]
         * @return {Function}      [description]
         */
        const callback = data => {
            //If is not exists statusCode,  so received 200 as default.
            if (typeof params.controller.statusCode === "undefined" || params.controller.statusCode === '') {
                params.controller.statusCode = 200;
            }

            const responseHeader = params.controller.responseHeader ? params.controller.responseHeader : {'Content-Type': 'application/json; charset=utf8'};
            response.writeHead(params.controller.statusCode, responseHeader);
            request.pipe(response);
            response.end(params.controller.responseHeader ? data : JSON.stringify(data));
        };

        if (request.method === 'GET') {
            this.get(request, response, params, callback);
        }

        if (request.method === 'POST') {
            this.post(request, response, params, callback);
        }

        if (request.method === 'PUT') {
            this.put(request, response, params, callback);
        }

        if (request.method === 'DELETE') {
            this.delete(request, response, params, callback);
        }

        if (request.method === 'OPTIONS') {
            response.writeHead(200);
            response.end();
        }
    }

    /**
     * Handle the http request method GET.
     * @param {Object} request .
     * @param {Object} response .
     * @param {Object} params .
     * @param {function} callback .
     * @return {VoidFunction} .
     */
    get(request, response, params, callback) {
        this.getQuery(request, query => {
            params.controller.query = query;
            this.beforeFilter(params.controller, data => {
                if (data) {
                    callback(data);

                    return;
                }

                if (params.action) {
                    this.callAction(params, request, response, callback);
                } else {
                    params.controller.get(callback);
                }
            });
        });
    }

    /**
     * Handle the http request method POST.
     * @param {Object} request .
     * @param {Object} response .
     * @param {Object} params .
     * @param {function} callback .
     * @return {VoidFunction} .
     */
    post(request, response, params, callback) {
        this.getPayload(request, payload => {
            params.controller.payload = payload;
            this.beforeFilter(params.controller, data => {
                if (data) {
                    callback(data);

                    return;
                }

                //Call action if exists. Otherwise call post.
                if (params.action) {
                    this.callAction(params, request, response, callback);
                } else {
                    params.controller.post(callback);
                }
            });
        });
    }

    /**
     * Handle the http request method PUT.
     * @param {Object} request .
     * @param {Object} response .
     * @param {Object} params .
     * @param {function} callback .
     * @return {VoidFunction} .
     */
    put(request, response, params, callback) {
        this.getPayload(request, payload => {
            params.controller.payload = payload;
            this.beforeFilter(params.controller, data => {
                if (data) {
                    callback(data);

                    return;
                }

                if (params.action) {
                    this.callAction(params, request, response, callback);
                } else {
                    params.controller.put(callback);
                }
            });
        });
    }

    /**
     * Handle the http request method DELETE.
     * @param {Object} request .
     * @param {Object} response .
     * @param {Object} params .
     * @param {function} callback .
     * @return {VoidFunction} .
     */
    delete(request, response, params, callback) {
        this.getPayload(request, payload => {
            params.controller.payload = payload;
            this.beforeFilter(params.controller, data => {
                if (data) {
                    callback(data);

                    return;
                }

                if (params.action) {
                    this.callAction(params, request, response, callback);
                } else {
                    params.controller.delete(callback);
                }
            });
        });
    }
}

module.exports = RequestHandler;
