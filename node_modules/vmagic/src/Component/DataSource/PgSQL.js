/*eslint max-statements: ["error", 100], max-depth: ["error", 10], class-methods-use-this: ["error", { "exceptMethods": ["_getWhereSQL","_getSelectSQL"] }] */
'use strict';

const Promise = require("bluebird");
const {Pool} = require("pg");
const Logger = require("../Logger.js");
let pool = null;

class PgSQL {

    constructor(dbConfig) {
        this.dbConfig = dbConfig;
        this.logger = new Logger();
    }

    createPool() {
        let connectionLimit = 10;
        if (this.dbConfig.connectionLimit) {
            connectionLimit = this.dbConfig.connectionLimit;
        }

        pool = new Pool({
            "host" : this.dbConfig.host,
            "port" : this.dbConfig.port,
            "user" : this.dbConfig.user,
            "password" : this.dbConfig.password,
            "database" : this.dbConfig.database,
            "max" : connectionLimit
        });

        this.logger.success("Pool connection created successfully.");
    }

    connect() {
        return new Promise((resolve, reject) => {
            pool.connect((err, client) => {
                if (err) {
                    this.logger.error('[Magic] PgSQL Connection was not established.');
                    reject(err);
                } else {
                    this.logger.success('[Magic] PgSQL Connection established successfully.');
                    resolve(client);
                }
            });
        });
    }

    close(client) {
        this.logger.success('[Magic] PgSQL is closed successfully.');
        client.release();
    }

    _getWhereSQL(table, params, indexParam = 0) {
        let where = '';
        const arrayValues = [];

        /*
         * It's creates the conditions for where.
         */
        if (Reflect.has(params, 'conditions')) {
            if (!Array.isArray(params.conditions) && typeof params.conditions == "object") {
                let index = indexParam;
                for (const key in params.conditions) {
                    if (Reflect.has(params.conditions, key)) {
                        index += 1;

                        let column = "";
                        if (key.indexOf(".") > -1) {
                            column = key;
                        } else {
                            column = `${table}.${key}`;
                        }

                        if (index == indexParam + 1) {
                            where += `WHERE ${column} = $${index}`;
                        } else {
                            where += ` AND ${column} = $${index}`;
                        }

                        arrayValues.push(params.conditions[key]);
                    }
                }
            } else if (Array.isArray(params.conditions)) {
                let countParam = indexParam;
                for (let index = 0; index < params.conditions.length; index += 1) {
                    const obj = params.conditions[index];
                    const arrayKeys = Reflect.ownKeys(obj);
                    let conditions = null;
                    let operationValue = '=';
                    const values = obj[arrayKeys[0]];
                    countParam += 1;

                    //Check if necessary to add the table name before field.
                    if (arrayKeys[0].indexOf(".") > -1) {
                        conditions = arrayKeys[0];
                    } else {
                        conditions = `${table}.${arrayKeys[0]}`;
                    }

                    //If found the operation value.
                    if (arrayKeys[1]) {
                        operationValue = obj[arrayKeys[1]];

                        if (operationValue.trim() === "") {
                            operationValue = "";
                        } else if (operationValue.toUpperCase() === 'BETWEEN') {
                            operationValue += ` $${countParam} AND $${countParam + 1}`;
                            countParam += 1;
                        } else if (operationValue.toUpperCase() === 'IN') {
                            operationValue += " (";
                            for (var index2 = 0; index2 < values.length; index2 += 1) {
                                if (index2 === values.length - 1) {
                                    operationValue += `$${countParam}`;
                                } else {
                                    operationValue += `$${countParam}, `;
                                }
                                countParam += 1;
                            }
                            operationValue += ")";
                        } else if (operationValue.toUpperCase() !== 'IS NULL' && operationValue.toUpperCase() !== 'IS NOT NULL') {
                            operationValue += ` $${countParam}`;
                        }
                    } else {
                        operationValue += ` $${countParam}`;
                    }

                    if (index === 0) {
                        where += `WHERE ${conditions} ${operationValue}`;
                    } else {
                        where += ` AND ${conditions} ${operationValue}`;
                    }

                    //Iterate array values.
                    if (Array.isArray(values)) {
                        for (let indexValue = 0; indexValue < values.length; indexValue += 1) {
                            arrayValues.push(values[indexValue]);
                        }
                    } else {
                        arrayValues.push(values);
                    }
                }
            }
        }

        return {"where" : where, "values" : arrayValues};
    }

    _getSelectSQL(table, params) {
        if (!params) {
            return {"sql" : `SELECT * FROM ${table}`, "values" : []};
        }

        const obj = this.prepareSQL(table, params);
        let sql = `SELECT ${obj.columns} FROM ${table}`;

        sql += obj.join ? ` ${obj.join}` : "";
        sql += obj.where ? ` ${obj.where}` : "";
        sql += obj.group ? ` ${obj.group}` : "";
        sql += obj.order ? ` ${obj.order}` : "";
        sql += obj.limit ? ` ${obj.limit}` : "";

        return {"sql" : sql, "values" : obj.values};
    }

    _getCount(table, params) {
        if (!params) {
            return {"sql" : `SELECT COUNT(*) FROM ${table}`, "values" : []};
        }

        const obj = this.prepareSQL(table, params);
        let sql = `SELECT COUNT(*) FROM ${table}`;

        sql += obj.join ? ` ${obj.join}` : "";
        sql += obj.where ? ` ${obj.where}` : "";
        sql += obj.group ? ` ${obj.group}` : "";

        return {"sql" : sql, "values" : obj.values};
    }

    prepareSQL(table, params) {
        const response = {
            "columns" : "*",
            "group" : "",
            "order" : "",
            "limit" : "",
            "join" : ""
        };

        let conditions = null;
        if (Reflect.has(params, "conditions")) {
            conditions = this._getWhereSQL(table, params);
        } else {
            conditions = this._getWhereSQL(table, {"conditions" :  params});
        }

        response.values = conditions.values;

        if (conditions.where !== "") {
            response.where = conditions.where;
        }

        if (Reflect.has(params, 'fields') && params.fields.length > 0) {
            const arrayColumns = [];
            for (let ind = 0; ind < params.fields.length; ind += 1) {
                if (params.fields[ind].indexOf(".") > -1) {
                    arrayColumns.push(params.fields[ind]);
                } else {
                    arrayColumns.push(`${table}.${params.fields[ind]}`);
                }
            }
            response.columns = arrayColumns.join();
        }

        if (Reflect.has(params, 'order') && params.order.length > 0) {
            const arrayOrder = [];
            for (let ind = 0; ind < params.order.length; ind += 1) {
                if (params.order[ind].indexOf(".") > -1) {
                    arrayOrder.push(params.order[ind]);
                } else {
                    arrayOrder.push(`${table}.${params.order[ind]}`);
                }
            }
            response.order = `ORDER BY ${arrayOrder.join()}`;
        }

        if (Reflect.has(params, 'group') && params.group.length > 0) {
            const arrayGroups = [];
            for (let ind = 0; ind < params.group.length; ind += 1) {
                if (params.group[ind].indexOf(".") > -1) {
                    arrayGroups.push(params.group[ind]);
                } else {
                    arrayGroups.push(`${table}.${params.group[ind]}`);
                }
            }
            response.group = `GROUP BY ${arrayGroups.join()}`;
        }

        if (Reflect.has(params, 'limit')) {
            response.limit = `LIMIT ${params.limit}`;
        }

        if (Reflect.has(params, 'join')) {
            let join = "";
            if (!Array.isArray(params.join) && typeof params.join == "object") {
                const joinProperties = Reflect.ownKeys(params.join);
                const joinType = joinProperties[0];
                const joinCondition = params.join[joinType];
                join += `${joinType} JOIN ${joinCondition.table} ON ${joinCondition.on} `;
            } else if (Array.isArray(params.join)) {
                for (const ind in params.join) {
                    if (Reflect.has(params.join, ind)) {
                        const joinItem = params.join[ind];
                        const keyJoin = Object.keys(joinItem);
                        join += `${keyJoin} JOIN ${joinItem[keyJoin].table} ON ${joinItem[keyJoin].on} `;
                    }
                }
            }
            response.join = join;
        }

        return response;
    }

    delete(table, conditions, connection = null) {
        const objWhere = this._getWhereSQL(table, {"conditions" : conditions});
        if (this._showSQL) {
            this.logger.info(`[Magic] DELETE FROM ${table} ${objWhere.where}`);
        }

        return new Promise((resolve, reject) => {
            if (connection) {
                const sql = `DELETE FROM ${table} ${objWhere.where}`;
                connection.query(sql, objWhere.values, (error, result) => {
                    if (error) {
                        reject(error);
                    } else {
                        resolve(result);
                    }
                });
            } else {
                this.connect().then(newConnection => {
                    const sql = `DELETE FROM ${table} ${objWhere.where}`;
                    newConnection.query(sql, objWhere.values, (error, result) => {
                        this.close(newConnection);
                        if (error) {
                            reject(error);
                        } else {
                            resolve(result);
                        }
                    });
                }).catch(error => {
                    reject(error);
                });
            }
        });
    }

    save(table, data, connection = null) {
        let insertInto = `INSERT INTO ${table} (`;
        let index = 0;
        let fields = '';
        let values = "VALUES (";
        const totalKeys = Object.keys(data).length;
        const arrayValues = [];
        for (const key in data) {
            if (Reflect.has(data, key)) {
                index += 1;
                if (index < totalKeys) {
                    fields += `${key},`;
                    values += `$${index},`;
                } else {
                    fields += `${key}) `;
                    values += `$${index}) RETURNING *;`;
                }
                arrayValues.push(data[key]);
            }
        }
        insertInto += fields + values;
        if (this._showSQL) {
            this.logger.info(`[Magic] ${insertInto}`);
        }

        return new Promise((resolve, reject) => {
            if (connection) {
                connection.query(insertInto, arrayValues, (error, result) => {
                    if (error) {
                        reject(error);
                    } else {
                        resolve(result);
                    }
                });
            } else {
                this.connect().then(newConnection => {
                    newConnection.query(insertInto, arrayValues, (error, result) => {
                        this.close(newConnection);
                        if (error) {
                            reject(error);
                        } else {
                            resolve(result);
                        }
                    });
                }).catch(error => {
                    reject(error);
                });
            }
        });
    }

    async saveMany(table, data, connection = null) {
        const that = this;
        let conn = null;

        if (connection) {
            conn = connection;
        } else {
            conn = await this.connect();
            if (connection === null) {
                await conn.query("BEGIN");
            }
        }

        const arrayPromises = [];
        for (let index = 0; index < data.length; index += 1) {
            arrayPromises.push(that.save(table, data[index], conn));
        }

        try {
            const arrayResponse = await Promise.all(arrayPromises);
            if (connection === null) {
                await conn.query('COMMIT');
            }

            return Promise.resolve(arrayResponse);
        } catch (err) {
            if (connection === null) {
                await conn.query("ROLLBACK");
            }

            return Promise.reject(new Error(err.message));
        } finally {
            if (connection === null) {
                that.close(conn);
            }
        }
    }

    update(table, data, conditions, connection = null) {
        let update = `UPDATE ${table} SET `;
        const arrayValues = [];
        let index = 0;

        const totalKeys = Object.keys(data).length;
        for (const key in data) {
            if (Reflect.has(data, key)) {
                index += 1;
                arrayValues.push(data[key]);
                if (index < totalKeys) {
                    update += `${key} = $${index}, `;
                } else {
                    update += `${key} = $${index}`;
                }
            }
        }

        const objWhere = this._getWhereSQL(table, {"conditions" : conditions}, index);
        const values = arrayValues.concat(objWhere.values);
        if (this._showSQL) {
            this.logger.info(`[Magic] ${update} ${objWhere.where}`);
        }

        return new Promise((resolve, reject) => {
            if (connection) {
                connection.query(`${update} ${objWhere.where} RETURNING *`, values, (error, result) => {
                    if (error) {
                        reject(error);
                    } else {
                        resolve(result);
                    }
                });
            } else {
                this.connect().then(newConnection => {
                    newConnection.query(`${update} ${objWhere.where} RETURNING *`, values, (error, result) => {
                        this.close(newConnection);
                        if (error) {
                            reject(error);
                        } else {
                            resolve(result);
                        }
                    });
                }).catch(error => {
                    reject(error);
                });
            }
        });
    }

    findBy(table, data, _params, connection = null) {
        let params = {};
        if (_params) {
            params = _params;
        }
        params.conditions = data;
        const objParams = this._getSelectSQL(table, params);
        if (this._showSQL) {
            this.logger.info(`[Magic] ${objParams.sql}`);
        }

        return new Promise((resolve, reject) => {
            if (connection) {
                connection.query(objParams.sql, objParams.values, (error, result) => {
                    if (error) {
                        reject(error);
                    } else {
                        resolve(result);
                    }
                });
            } else {
                this.connect().
                    then(newConnection => {
                        newConnection.query(objParams.sql, objParams.values, (error, result) => {
                            this.close(newConnection);
                            if (error) {
                                reject(error);
                            } else {
                                resolve(result);
                            }
                        });
                    }).catch(error => {
                        reject(error);
                    });
            }
        });
    }

    findAll(table, params, connection = null) {
        const objParams = this._getSelectSQL(table, params);
        if (this._showSQL) {
            this.logger.info(`[Magic] ${objParams.sql}`);
        }

        return new Promise((resolve, reject) => {
            if (connection) {
                connection.query(objParams.sql, objParams.values, (error, result) => {
                    if (error) {
                        reject(error);
                    } else {
                        resolve(result);
                    }
                });
            } else {
                this.connect().then(newConnection => {
                    newConnection.query(objParams.sql, objParams.values, (error, result) => {
                        this.close(newConnection);
                        if (error) {
                            reject(error);
                        } else {
                            resolve(result);
                        }
                    });
                }).catch(error => {
                    reject(error);
                });
            }
        });
    }

    find(table, type, params, connection = null) {
        let objParams = null;
        if (type === "count") {
            objParams = this._getCount(table, params);
        } else {
            return Promise.reject(new Error(`Command ${type} not found.`));
        }

        if (this._showSQL) {
            this.logger.info(`[Magic] ${objParams.sql}`);
        }

        return new Promise((resolve, reject) => {
            if (connection) {
                connection.query(objParams.sql, objParams.values, (error, result) => {
                    if (error) {
                        reject(error);
                    } else {
                        resolve(result);
                    }
                });
            } else {
                this.connect().then(newConnection => {
                    newConnection.query(objParams.sql, objParams.values, (error, result) => {
                        this.close(newConnection);
                        if (error) {
                            reject(error);
                        } else {
                            resolve(result);
                        }
                    });
                }).catch(error => {
                    reject(error);
                });
            }
        });
    }

    showSQL() {
        this._showSQL = true;
    }
}

module.exports = PgSQL;
